# 암호학

## 키와 주소

이더리움은 외부 소유 계정(EOA)과 컨트랙트라는 두 가지 유형의 계정을 갖고 있다. 디지털 개인키, 이더리움 주소, 디지털 서명을 통해 외부 소유 계정의 이더 소유권을 확립한다. 개인키는 모든 사용자와 이더리움 간 상호작용의 핵심이다. 계정 주소는 개인키에서 직접 파생되고, 개인키는 계정이라고도 불리는 단일 이더리움 주소를 고유하게 결정한다.

이더리움 시스템은 개인키를 이더리움에 전송하거나 저장하는 방식으로 직접 사용하지 않는다. 개인키는 비공개로 유지되어야 하고, 네트워크로 전달된 메시지에 나타나지 않으며, 체인에 저장되어서도 안 된다.

개인키를 사용하여 생성된 디지털 서명을 통해 자금의 접근과 통제가 이루어진다. 이더리움 트랜잭션은 유효한 디지털 서명이 블록체인에 있어야 한다. 개인키의 사본을 가진 사람은 누구나 해당 계정과 해당 계정이 가진 이더를 제어할 수 있다. 사용자가 자신의 개인키를 안전하게 유지한다면, 이더리움 트랜잭션의 디지털 서명은 개인키의 소유권을 증명하기 때문에 자금의 실제 소유자임도 증명한다.

이더리움과 같은 공개키 암호화 기반 시스템에서 키는 개인키와 공개키로 구성된 쌍으로 제공한다. 공개키는 은행 계좌 번호, 개인키는 PIN과 유사하다고 볼 수 있다. 후자는 계정에 대한 제어권을 제공하고, 전자를 가지고 계정을 식별할 수 있다.

외부 소유 계정의 이더리움 주소는 공개키-개인키 쌍의 공개키 부분에서 생성된다. 그러나 모든 이더리움 주소가 공개키-개인키 쌍을 나타내는 것은 아니다.

## 공개키 암호화와 암호화폐

공개키 암호화(비대칭 암호화)는 오늘날 정보 보안의 핵심 요소다. 공개키 암호화는 고유한 키를 사용해 정보를 보호한다. 이 키는 특수한 속성을 가진 수학 함수를 바탕으로 한다. 이 함수를 바탕으로한 암호화는 디지털 비밀과 위조 불가능한 디지털 서명을 만들 수 있으며, 이것은 수학 법칙에 의해 보장받는다.

역산하기 위한 단축키로 사용할 수 있는 비밀 정보가 없으면 거꾸로 계산하기 어려운 함수를 트랩 도어 함수라고 한다. 타원 곡선의 산술 연산은 수학 함수의 더 발전된 범주인데, 타원 곡선 산술에서 소수로 나눈 나머지를 곱하는 것은 간단하지만, 나눗셈(역함수)은 사실상 불가능하다. 이를 이산 로그 문제라고 하며, 알려진 트랩 도어는 없다. 타원 곡선 암호화는 최신 컴퓨터 시스템에서 광범위하게 활용되며, 이더리움에서 개인키와 디지털 서명을 사용하는 기초가 된다.

공개키는 개인키에서 파생되므로 쌍으로 간주한다. 그 쌍은 공개적으로 접근할 수 있는 계정 핸들(주소)와 계정의 이더에 대한 접근 권한, 스마트 컨트랙트를 사용할 때 계정이 필요로 하는 모든 인증에 대한 사적 제어권을 제공함으로써 이더리움 계정을 나타낸다. 개인키는 계정에서 자금을 지출하기 위해 트랜잭션에 서명해야 하는 디지털 서명을 만드는 데 필요한 고유한 정보의 접근을 제어한다. 디지털 서명은 소유자 또는 컨트랙트 사용자를 인증하는 데도 사용한다.

디지털 서명을 만들어 모든 메시지에 서명할 수 있다. 이더리움 트랜잭션에서는 트랜잭션 자체의 세부사항이 메시지로 사용된다. 암호 수학은 메시지를 개인키와 결합해 개인키를 알아야만 만들 수 있는 코드 생성 방법을 제공한다. 이 코드를 디지털 서명이라고 한다. 이더리움 트랜잭션은 기본적으로 특정 이더리움 주소로 특정 계정에 접근하는 요청이다. 자금을 이동하거나 스마트 컨트랙트와 상호작용하기 위한 트랙잭션을 이더리움 네트워크로 보내면, 문제의 이더리움 주소에 해당하는 개인키로 생덩된 디지털 서명도 함께 보내야 한다. 타원 곡선 수학이란 디지털 서명, 트랜잭션 세부 정보, 접근하려는 이더리움 주소가 일치하는지 확인해 ‘누구나' 트랜잭션이 유효한지 확인할 수 있음을 의미한다. 이러한 확인 과정에는 개인키가 전혀 포함되지 않는다. 개인키는 개인 영역에 남아 있다. 그러나 검증 프로세스에서는 의심의 여지 없이 그 트랜잭션이 공개키에 대응되는 개인키를 가진 사람에 의해 만들어졌음을 확증할 수 있다.

## 개인키

개인키는 단순히 무작위로 선택한 숫자다. 개인키의 소유권과 제어는 해당 주소를 승인하는 컨트랙트에 대한 접근뿐만 아니라 해당 이더리움 주소와 관련된 모든 자금에 대한 사용자 제어의 근원이다. 개인키는 트랜잭션에 쓰이는 자금의 소유권을 증명함으로써 이더를 소비하는데 필요한 서명을 만드는 데 사용된다. 개인키는 항상 비밀로 유지해야 한다. 개인키를 잃어버리면 해당 키로 확보한 자금을 영원히 읽기 때문에 반드시 백업해야 한다.

## 난수로 개인키 생성

키를 생성하는 가장 중요한 첫 번째 단계는 엔트로피, 즉 무작위성을 확보하는 것이다. 이더리움 개인키를 생성하는 것은 기본적으로 1에서 2의 256승 사이의 숫자를 선택하는 것이라고 볼 수 있다. 이더리움 소프트웨어는 기본 운영체제의 난수 생성기를 사용해 256개의 임의 비트를 생성한다. 

정확히는 2의 256승보다 약간 작은 0이 아닌 매우 큰 숫자까지 가능하다. 정확한 숫자는 첫 번째 38자리를 2의 256승으로 공유하며, 이더리움에서 사용된 타원 곡선의 순서로 정의한다. 비공개 키를 생성하기 위해 256비트 숫자를 무작위로 추출해 유효한 범위 내에 있는지 확인한다. 프로그래밍 측면에서 이것은 일반적으로 더 큰 임의의 비트 문자열을 Keccak-256 또는 SHA-256 같은 256비트 해시 알고리즘에 공급함으로써 이루어진다.

개인키 생성 프로세스는 오프라인 프로세스다. 이더리움 네트워크와의 통신이나 다른 사람과의 통신을 필요로 하지 않는다. 아무도 선택할 수 없는 숫자를 선택하려면 그것은 정말로 무작위어야 한다.

## 공개키

이더리움 공개키는 타원 곡선에 있는 점으로 타원 곡선 방정식을 만족하는 x와 y 좌표의 집합을 의미한다. 더 간단하게 말하면 이더리움 공개키는 함께 결합된 2개의 숫자다. 이 숫자는 개인키로부터 단방향으로만 계산할 수 있다. 개인키로 공개키를 계산하기는 쉽지만, 공개키에서 개인키를 계산할 수는 없다.

공개키는 사실상 비가역적인 타원 곡선 곱셉을 사용해 개인키로부터 계산된다. K = k * G, 여기서 k는 개인키, G는 생성자 점이라고 불리는 상수점, K는 결과로 나오는 공개키, *는 특수 타원 곡선 ‘곱하기' 연산자다. 타원 곡석 곱셉은 일반적인 곱셈과 같지 않다. 역 연산은 가능한 모든 k 값을 시도하는 것만큼 어렵다.

타원 곡선에 대한 산술 연산은 ‘정규' 정수 연산과 다르다. G에 k를 곱하여 다른 K를 생성할 수 있다. 그러나 나눗셈 같은 연산이 존재하지 않으므로 공개키 K를 G 점으로 간단히 나누어서 개인키 k를 계산할 수 없다. 

## 타원 곡선 암호화 설명

이더리움은 미국 표준기술연구소에서 제정한 secp256k1이라는 표준에 정의한 대로 특정 타원 곡선과 수학 상수 집합을 사용한다. secp256k1 곡선은 타원 곡선을 생성하는 다음 함수로 정의한다.

`y의 제곱 = (x의 3제곱 + 7) over Fp`

`y의 제곱 mod p = (x의 3제곱 + 7) mod p`

mod p는 이 곡선이 Fp라고 쓰인 소수 차수 p의 유한체상에 있음을 나타낸다. 여기서 p = 2의 256제곱 - 2의 32제곱 - 2의 9제곱 - 2의 8제곱 - 2의 7제곱 - 2의 6제곱 - 2의 4제곱 - 1로 매우 큰 소수다.

## 공개키 생성

`K = k * G`

생성자 점 G는 secp256k1 표준의 일부로 지정되어 있다. secp256k1의 모든 구현에서 동일하며, 해당 곡선에서 파생된 모든 키는 동일한 점 G를 사용한다. 생성자 점은 모든 이더리움 사용자에 대해 항상 동일하기 때문에, G와 개인키 k를 곱한 결과는 항상 공개키 K로 동일하다. k와 K 사이의 관계는 항상 고정되어 있지만, k에서 K까지 한 방향으로만 계산할 수 있다. 이 이유로 이더리움 주소를 모든 사람과 공유할 수 있으며 사용자는 개인키는 공개하지 않는다.

## 암호화 해시 함수

해시 함수는 임의 크기의 데이터를 고정된 크기의 데이터로 매핑하는 데 사용할 수 있는 모든 함수다. 해시 함수에 대한 입력을 사전 이미지, 메시지 또는 단순히 입력 데이터라고 한다. 그리고 그 결과를 해시라고 한다.

암호 해시 함수는 임의 크기의 데이터를 고정 크기의 비트 열로 매핑하는 단방향 해시 함수다. 단방향 특성은 결과값 해시만 알고 있을 때 입력 데이터를 다시 작성하는 것이 계산적으로 불가능함을 의미한다. 유일한 방법은 무차별 대입 검색을 수행하는 것이다. 검색 공간이 사실상 무한하기 때문에 실제로 불가능하다는 것을 이해할 수 있다. 일치하는 해시를 만드는 일부 입력 데이터를 찾는다고 해도 해시 함수는 다대일 함수이기 때문에 원본 입력 데이터가 아닐 수 있다. 동일한 결과에 해시 처리한 두 입력 데이터 집합을 찾는 것을 해시 충돌 찾기라고 한다. 이더리움에서는 사실상 해시 충돌이 불가능하다.

암호화 해시 함수의 주요 속성

- 결정론(determinism): 주어진 입력 메시지는 항상 동일한 해시 결과를 생성한다.
- 검증성(verifiability): 메시지의 해시 계산은 효율적이다.(선형 복잡성)
- 비상관성(noncorrelation): 메시지에 대한 작은 변화는 해시 출력을 너무 광범위하게 변경해야 해서 원본 메시지의 해시와 상관 관계가 없다.
- 비가역성(irreversibility): 해시로부터 메시지를 계산하는 것은 불가능하다. 모든 가능한 메시지에 대한 무차별 검색과 같다.
- 충돌 방지(collision protection): 같은 해시 결과를 생성하는 2개의 서로 다른 메시지를 계산하는 것은 불가능하다.

이런 속성을 조합하면 데이터 핑커프리팅, 메시지 무결성, 작업 증명, 인증, 의사 난수 생성기, 메시지 커밋, 고유 식별자와 같은 보안 애플리케이션에서 유용하다.

## 이더리움의 암호화 해시 함수: Keccak-256

이더리움의 많은 곳에서 Keccak-256 암호화 해시 함수를 사용한다.

## 이더리움 주소

이더리움 주소는 Keccak-256 단방향 해시 함수를 사용하는 공개키 또는 컨트랙트에서 파생한 고유 식별자다. 

1. 개인키로 시작해 타원 곡선 곱셈을 사용해 공개키를 만든다 
2. Keccak-256을 사용해 이 공개키의 해시를 계산한다.
3. 이더리움 주소인 마지막 20바이트만 유지한다.
4. 접두어 0x로 표시되어 16진수로 인코딩된 것을 확인할 수 있다.

## 이더리움 주소 형식

이더리움 주소는 16진수이며, 공개키 Keccak-256 해시의 마지막 20바이트에서 파생한 식별자다. 모든 클라이언트의 사용자 인터페이스에 내장된 체크섬을 포함해 잘못 입력된 주소를 보호하도록 인코딩된 비트코인 주소와 달리 이더리움 주소는 체크섬이 없는 원시 16진수로 표시한다.

이 결정의 근거는 이더리움 주소가 결국 시스템의 상위 계층에서 추상화에 숨겨지고 필요하다면 상위 계층에 체크섬을 추가해야 한다는 것이다.

## 클라이언트 주소 상호교환 프로토콜

클라이언트 주소 상호교환 프로토콜(Inter exchange Client Address Protocol, ICAP)은 국제 은행 계좌 번호(International Bank Account Number, IBAN) 인코딩과 부분적으로 호환되는 이더리움 주소 인코딩으로, 이더리움 주소에 대해 다목적의 체크섬이 가능하고 상호운용 가능한 인코딩을 제공한다. ICAP 주소는 이더리움 이름 레지스트리에 등록한 이더리움 주소 또는 일반 이름을 인코딩할 수 있다. 

IBAN은 은행 계좌 번호를 식별하기 위한 국제 표준으로 주로 은행 송금에 사용하며, 유럽 단일 유로 지급 지역 및 그 이상 지역에서 광범위하게 채택된다.
