# 이더리움 클라이언트

이더리움 클라이언트는 이더리움 사양을 구현하고 다른 이더리움 클라이언트와 피어투피어 네트워크를 통해 통신하는 소프트웨어 애플리케이션이다. 기준 사양과 표준 통신 프로토콜을 준수한다면, 서로 다른 이더리움 클라이언트끼리 상호운용이 가능하다. 이더리움은 오픈 소스 프로젝트이며, 모든 주요 클라이언트의 소스 코드는 오픈 소스 라이선스하에서 사용할 수 있다. 

비트코인은 이와 달리 공식적인 방식으로 정의되지 않는다. 비트코인의 ‘사양'이 비트코인 코어 기준 구현체인 반면, 이더리움은 영어와 수학(공식) 사양이 결합되어 문서화되어 있다. 이 공식 사양은 다양한 이더리움 개선 제안과 함께 이더리움 클라이언트의 표준 작동 방식을 정의한다. 황서는 이더리움에 주요 변경사항이 적용됨에 따라 주기적으로 업데이트된다.

이더리움은 다른 블록체인보다 네트워크에서 실행되는 구현의 다양성이 더 크며, 이는 일반적으로 좋은 점으로 평가된다. 실제로 이더리움은 네트워크 공격을 방어하기 위한 훌륭한 방법으로 입증되었다. 왜냐하면 특정 클라이언트의 구현 전략을 악용하는 것은 개발자가 공격을 패치하는 동안 개발자를 괴롭하지만 다른 클라이언트는 네트워크에 거의 영향을 주지 않기 때문이다.

## 이더리움 네트워크

이더리움 기반 네트워크 중에는 서로 간에 상호 운용되지 않을 수도 있는 것들이 많이 있다. 이더리움 기반 네트워크는 이더리움, 이더리움 클래식, 엘라, 익스팬스, 유비크, 뮤지코인 및 기타 여러 네트워크가 있다. 대부분 프로토콜 수준에서 호환되는 반면, 각 소프트웨어 관리자가 각 네트워크를 지원하기 위해 작은 변경을 요구하는 기능 또는 속성을 가지고 있는 경우가 많다. 이 때문에 소프트웨어의 모든 버전이 모든 이더리움 기반 블록체인을 실행하는 것은 아니다.

현재 여섯 가지 언어로 작성된 이더리움 프토토콜의 기본 구현이 있다.

- 러스트(Rust)로 작성된 패리티(Parity)
- 고(Go)로 작성된 게스(Geth)
- C++로 작성된 cpp-ethereum
- 파이썬(Python)으로 작성된 pyethereum
- 스칼라(Scala)로 작성된 맨티스(Mantis)
- 자바(Java)로 작성된 하모니(Harmony)

각 클라이언트를 사용해 노드를 설정하고 커맨드 라인 및 API 중 일부를 탐색하는 방법을 학습한다.

## 풀 노드를 실행해야 하는가?

블록체인의 건전성, 복원력, 검열 저항 특성은 독립적으로 운용되고 지리적으로 분산된 풀 노드가 얼마나 많은지에 달려 있다. 각각의 풀노드는 다른 새 노드가 블록 데이터를 얻어 작업을 부트스트랩하고, 운영자에게 모든 트랜잭션 및 컨트랙트에 대해 신뢰할 수 있고 독립적인 검증을 제공할 수 있도록 도와준다.

풀 노드를 실행하면 하드웨어 자원 및 대역폭 비용이 발생한다. 풀 노드는 80 ~ 100GB 정도의 데이터를 다운로드해야 하며, 로컬 하드 디스크에 저장해야 한다. 새로운 트랜잭션 및 블록이 추가되면서 매일 이러한 데이터 부담이 상당히 빠르게 증가한다.

이더리움 개발에는 라이브 메인넷 네트워크에서 실행 중인 풀 노드가 필요하지 않다. 테스트넷 노드, 가나슈 같은 로컬 사설 블록체인 또는 인퓨라 같은 서비스 공급자가 제공하는 클라우드 기반 이더리움 클라이언트로 원하는 대부분의 작업을 수행할 수 있다.

블록체인의 로컬 사본을 저장하지 않거나 블록 및 트랜잭션의 유효성을 확인하지 않는 원격 클라이언트를 실행할 수도 있다. 이 클라이언트는 지갑의 기능을 제공하며 트랜잭션을 생성하고 전파할 수 있다. 원격 클라이언트를 사용하여 자신의 풀 노드, 공개 블록체인, 공개 또는 허가된 테스트넷 또는 개인 로컬 블록체인 같은 기존 네트워크에 연결할 수 있다. 실제로 다른 모든 노드 옵션 간에 전환하기 위한 편리한 방법으로 메타 마스크, 에메랄드 지갑, 마이이더월렛, 마이크립토 같은 원격 클라이언트를 사용할 것이다.

원격 클라이언트 및 지갑이라는 용어는 혼용되어 사용된다. 하지만 일반적으로 원격 클라이언트는 지갑의 트랜잭션 기능 외에도 API를 제공한다.

이더리움의 원격 지갑 개념을 라이트 클라이언트의 개념과 혼동하면 안 된다. 라이트 클라이언트는 블록 헤더의 유효성을 검사하고, 머클 증명을 사용해 블록체인에서의 트랜잭션 포함 여부를 확인하고 그 영향도를 결정해 풀 노드에 대해 비슷한 수준의 보안을 제공한다. 반대로, 이더리움 원격 클라이언트는 블록 헤더 또는 트랜잭션의 유효성을 검사하지 않는다. 그들은 풀 클라이언트를 신뢰해 블록체인에 대한 접근 권한을 부여하므로 보안 및 익명성 보장 수준이 상당히 떨어진다. 스스로 실행하는 풀 클라이언트를 사용해 이러한 문제를 완화할 수 있다.

## 풀 노드의 장단점

### 장점

- 이더리움 기반 네트워크의 복원력과 검열 저항을 지원
- 모든 트랜잭션을 정식으로 검증
- 중개자 없이 공개 블록체인의 모든 컨트랙트와 상호작용 가능
- 중개자 없이 컨트랙트를 공개 블록체인에 직접 배포 가능
- 블록체인 상태를 오프라인에서 조회 가능(읽기 전용)
- 읽은 정보를 제3자에게 노출하지 않고 가져오기 가능

### 단점

- 하드웨어와 대역폭 자원의 확대가 필요하다.
- 처음 시작할 때 전체 동기화를 위해 여러 날이 소요된다.
- 동기화를 유지하기 위해 관리하고, 업그레이드하고, 온라인 상태로 유지해야 한다.

## 공개 테스트넷의 장단점

### 장점

- 훨씬 적은 데이터(약 10GB)와 동기화
- 몇 시간 내에 전체 동기화
- 컨트랜트 배포 및 트랜잭션 생성을 위한 테스트용 이더를 몇몇 Faucet으로부터 무료로 얻기 가능
- 다른 많은 스마트 컨트랙트가 동작 실행 중인 공개 블록체인

### 단점

- 실제 돈을 사용할 수 없음. 따라서 악의적 사용자들에 대응하는 실전 보안성 테스트를 할 수 없음.
- 퍼블릭 블록체인에서만틈 실전 테스트를 할 수 없음. 가스 수수료를 고려하지 않기 때문. 네트워크 혼잡도 없음.

## 로컬 블록체인 시뮬레이션의 장단점

- 테스트 목적에 가장 좋은 선택은 단일 인스턴스 사설 블록체인을 실행하는 것이다. 가나슈는 다른 어떤 참여자들 없이 상호작용할 수 있는 가장 인기 있는 로컬 블록체인 시뮬레이션 중 하나다.

### 장점

- 동기화가 없고 디스크에 데이터가 거의 없음. 직접 첫 번째 블록을 채굴할 수 있음.
- 테스트 이더를 얻을 필요 없음. 채굴 보상을 자신에게 수여할 수 있음.
- 다른 사용자와 컨트랜트가 없음.

### 단점

- 공개 블록체인과 동일하게 작동하지 않음. 트랜잭션 순서나 공간을 두고 경쟁이 없음.
- 채굴이 예측 가능해 공개 블록체인에서 발생하는 일부 시나리오를 테스트할 수 없음.
- 테스트를 위해 의존성을 갖는 것들과 컨트랙트 라이브러리를 포함해 모든 것을 배포해야 함.
- 어떤 시나리오를 테스트하기 위한 공개 컨트랙트와 주소를 다시 만들지 못할 수 있음.

## 풀 노드를 위한 하드웨어 요구사항

이더리움 블록체인 크기: [https://bitinfocharts.com/ethereum/](https://bitinfocharts.com/ethereum/)

## 클라이언트(노드)를 빌드하고 실행하기 위한 소프트웨어 요구사항

고(Go) 설치: [https://go.dev/](https://go.dev/)

러스트(Rust) 설치: [https://rustup.rs/](https://rustup.rs/)

위키 지침:

[https://github.com/openethereum/parity-ethereum](https://github.com/openethereum/parity-ethereum)

## 패리티

패리티(Parity)는 풀 노드 이더리움 클라이언트 및 댑 브라우저를 구현한 것이다. 패리티는 모듈식의 안전하고 확장 가능한 이더리움 클라이언트를 구축하기 위해 시스템 프로그래밍 언어인 러스트 기반으로 작성되었다.

### 패리티 설치

```
git clone https://github.com/paritytech/parity
```

parity 디렉터리로 변경하고 cargo를 사용해 실행 파일을 작성한다.

```
cd parity
cargo install
parity --version
```

패리티가 설치되었다면 블록체인을 동기화하고 기본 커맨드 라인 옵셥을 시작할 수 있다.

## 게스

게스(Go-Ethereum, Geth)는 이더리움 재단에서 고(Go) 언어로 개발했으며, 이더리움의 ‘공식’ 클라이언트다. 일반적으로 모든 이더리움 기반 블록체인은 자체 게스 구현을 갖고 있다. 

```
git clone https://github.com/ethereum/go-ethereum.git
```

```
cd go-ethereum
make geth
```

게스 빌드를 위해 소스 코드를 다운로드한 디렉토리로 이동하고 make 명령을 사용한다.

```
./build/bin/geth version
```

```
Geth
Version: 1.10.19-unstable
Git Commit: be9742721f56eb8bb7ebf4f6a03fb01b13a05408
Git Commit Date: 20220527
Architecture: arm64
Go Version: go1.18.2
Operating System: darwin
GOPATH=
GOROOT=go
```

## 이더리움 기반 블록체인의 첫 번째 동기화

이더리움 클라이언트는 트랜잭션의 전체 유효성 검사를 건너뛰고 블록체인의 일부에 동기화될 때까지 ‘빠른' 동기화를 수행하는 옵션을 포함한다. 그런 다음 유효성 검사를 다시 재개한다. 게스의 경우에는 빠른 동기화를 활성화하는 옵션으로 --fast가 있지만, 선택한 이더리움 체인의 특정 지침을 참고해야 할 수도 있다.

## JSON-RPC 인터페이스

이더리움 클라이언트는 애플리케이션 인터페이스와 JSON(JavaScript Object Notation)으로 인코딩된 RPC(Remote Procedure Call) 명령을 제공한다. JSON-RPC API를 참고해 이 명령을 볼 수 있다. 기본적으로 이더리움 클라이언트를 이더리움 네트워크 및 블록체인의 게이트웨이로 사용하는 프로그램을 작성할 수 있게 해주는 인터페이스이다.

일반적으로 RPC 인터페이스는 포트 8545에서 HTTP 서비스로 제공된다. 기본적으로 보안상의 이유로 로컬 호스트의 연결만 허용하도록 제한된다.

JSON-RPC API에 접근하려면 사용 가능한 각 RPC 명령에 해당하는 ‘스텁(stub)’ 함수 호출을 제공하는 특수 라이브러리를 사용하거나, HTTP 요청과 JSON으로 인코딩된 보내기/받기 요청을 수동으로 생성할 수 있다. curl 같은 일반적인 커맨드 라인 HTTP 클라이언트를 사용해 RPC 인터페이스를 호출할 수도 있다.

```
$ curl -x POST -H "Content-Type: application/json" --data \
  '{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}' \
  http://localhost:8545

{"jsonrpc":"2.0","id":1,
"result":"Geth/v1.8.0-unstable-02aeb3d7/linux-amd64/gol.8.3"}
```

이 예제에서는 [http://localhost:8545](http://localhost:8545) 주소로의 연결을 만들기 위해 curl 명령문을 사용한다. 이미 8545 포트에서 HTTP 서비스로서 JSON-RPC API를 제공하는 게스를 실행하고 있다. HTTP POST 명령을 사용하고 Content-Type: application/json 유형의 콘텐츠를 식별하기 위해 curl을 지시한다. 마지막으로, HTTP 요청의 데이터 요소로서 JSON으로 인코딩된 요청을 전달한다. 대부분의 커맨드 라인은 올바른 HTTP 연결을 만들기 위해 curl을 설정하는 것이다. 흥미로운 부분은 우리가 발행한 실제 JSON-RPC 명령이다.

```
{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}
```

JSON-RPC 요청은 JSON-RPC 2.0 사양에 따라 형식이 지정된다. 각 요청에는 네 가지 요소가 포함된다.

- jsonrpc: JSON-RPC 프로토콜의 버전. 정확히 2.0.
- method: 호출할 매서드의 이름
- params: 매서드를 호출하는 동안 사용할 파라미터 값을 보유하는 구조화된 값. params는 생략 가능
- id: 클라이언트가 설정한 식별자로 String, Number 혹은 NULL도 포함된다. 두 객체 간의 컨텍스트를 연결하는데 사용

응답 값은 아래와 같다.

```
{"jsonrpc":"2.0","id":1,
"result":"Geth/v1.8.0-unstable-02aeb3d7/linux-amd64/gol.8.3"}
```

이것은 JSON-RPC API가 게스 클라이언트 버전 1.8.0에서 서비스되고 있음을 알려준다.

다음 예제에서는 JSON-RPC API에 현재 가스 가격을 묻는다.

```
$ curl -x POST -H "Content-Type: application/json" --data \ 
  '{"jsonrpc":"2.0","method":"etc_gasPrice","params":[],"id":4213}' \
  http://localhost:8545

{"jsonrpc":"2.0","id":4213,"result":"0x430e23400"}
```

응답 0x430e23400은 현재 가스 가격이 18Gwei임을 알려준다. 

전체 JSON-RPC API는 [이더리움 위키](https://github.com/ethereum/wiki/wiki/JSON-RPC)에서 살펴볼 수 있다.

## 원격 이더리움 클라이언트

원격 클라이언트는 풀 클라이언트의 일부 기능을 제공한다. 원격 클라이언트는 더 빠르게 데이터 용량도 훨씬 더 적게 요구한다.

이러한 클라이언트는 일반적으로 다음 기능 중 하나 이상을 제공한다.

- 개인키와 이더리움 주소를 지갑에서 관리
- 트랜잭션 생성, 서명 및 브로드캐스트
- 데이터 페이로드(payload)를 사용해 스마트 컨트랙트와 상호연동
- 브라우저와 댑(Dapp) 간 상호연동
- 블록 탐색기 같은 외부 서비스 링크
- 이더 단위를 변환하고 외부 소스에서 환율을 검색
- 자바스크립트 객체로서 web3 인스턴스(instance)를 웹 브라우저에 삽입
- 다른 클라이언트가 브라우저에 제공/삽입한 web3 인스턴스를 사용
- 로컬 또는 원격 이더리움 노드에서 RPC 서비스로 접근

모바일(스마트폰) 지갑 같은 원격 클라이언트는 기본적인 지갑 기능만 제공한다. 다른 원격 클라이언트는 모든 기능을 갖춘 댑 브라우저다. 원격 클라이언트는 일반적으로 다른 곳에서 실행되고 있는 풀 노드에 연결해 이더리움 블록체인의 로컬 사본으로 동기화하지 않고 풀 노드 이더리움 클라이언트의 기능 중 일부만 제공한다. 예를 들어, 로컬에서 PC 혹은 웹 서버에서 또는 이더리움 서버에서 서드파티 제품을 통해 제공한다.

## 모바일(스마트폰) 지갑

스마트폰에는 전체 이더리움 클라이언트를 실행하는 데 필요한 자원이 충분하지 않기 때문에 모든 모바일 지갑은 원격 클라이언트다. 패리티의 경우 ‘실험 중(experimental)’으로 표시되어 있고 --light 옵션을 실행하여 사용할 수 있다. 인기 있는 모바일 지갑은 아래와 같다.

- 잭스
- 스태터스
- 트러스트월렛
- 사이퍼 브라우저

## 브라우저 지갑

다양한 지갑과 댑 브라우저는 크롬 및 파이어폭스 같은 웹 브라우저의 확장 혹은 플러그인 형태로 사용 가능하다. 이들은 브라우저 내부에서 실행되는 원격 클라이언트다. 인기가 많은 것으로는 메타마스크, 잭스, 마이이더월렛, 마이크립토, 미스트 등이 있다.

- 메타마스크: 여타 브라우저 지갑과 달리 다양한 이더리움 블록체인에 연결되는 PRC 클라이언트 역할을 하는 브라우저 자바스크립트 컨텍스트에 web3 인스턴스를 넣는다. web3 인스턴스 삽입 및 외부 RPC 서비스의 게이트웨이로서의 기능은 메타마스크를 개발자와 사용자를 위한 매우 강력한 도구로 만든다.
