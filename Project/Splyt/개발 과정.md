# Splyt 개발 과정

### 1. Mainnet의 NFT metadata를 가져와 Testnet에서 Minting하는 로직 개발

- 객체 지향 형태로 구현
- Testnet에서 테스트를 진행하기 위해 컨트랙트 복제하는 과정

**parser 구현**

```jsx
src/parser/klaytn/IParser.ts

export interface IParser {
  parse: (contractAddr: string) => Promise<number[]>;
}
```

```jsx
src/parser/klaytn/Parser.ts

import Caver, { ABI, AbiItem } from 'caver-js';
import { RPC_PROVIDER_MAP } from '../../klaytn';
import { Network } from '../../klaytn/types';
import { IParser } from './IParser';

export abstract class Parser implements IParser {
  private readonly _network: Network;
  private readonly _abi: ABI;

  constructor(network: Network, abi: ABI) {
    this._network = network;
    this._abi = abi;
  }

  protected _loadContract(contractAddr: string) {
    const caver = new Caver(RPC_PROVIDER_MAP[this._network]);

    return new caver.contract(this._abi as unknown as AbiItem[], contractAddr);
  }

  abstract parse(contractAddr: string): Promise<number[]>;
}
```

```jsx
src/parser/klaytn/KlaytnParser.ts

import { Parser } from './Parser';

export class klaytnParser extends Parser {
  private async _getAllMintedTokens(contractAddr: string) {
    const contract = super._loadContract(contractAddr);

    const mintedTotalSupply = await contract.methods.totalSupply().call();
		// TokenId가 0부터 순차적으로 발행된다는 가정에서 사용할 수 있다.
		// TokenId를 불러오는 함수를 사용 시 500 ~ 1000 이상의 call이 넘어가면 에러가 발생한다.
		// metadata를 불러오는 경우에도 마찬가지로 일정 이상의 call 시 에러가 발생한다.
		// 그럼에도 불구하고 사용한다고 하면 여러 번에 걸쳐서 진행되도록 로직을 작성해야 한다.

    return Array.from({ length: mintedTotalSupply }, (_, i) => i);
  }

  public async parse(contractAddr: string): Promise<number[]> {
    return this._getAllMintedTokens(contractAddr);
  }
}
```

**NFT deployer 구현**

```jsx
src/deployer/klaytn/IDeploy.ts

export interface IDeploy {
  deploy: (
    contractAddr: string,
    mintedTokens: number[],
    metadataURI: string,
  ) => void;
}
```

```jsx
src/deployer/klaytn/Deployer.ts

import Caver, { ABI, AbiItem } from 'caver-js';
import { RPC_PROVIDER_MAP } from '../../klaytn';
import { Network } from '../../klaytn/types';
import { IDeploy } from './IDeploy';

export abstract class Deployer implements IDeploy {
  private readonly _network: Network;
  private readonly _abi: ABI;
  private readonly _privateKey: string;

  constructor(network: Network, abi: ABI, privateKey: string) {
    this._network = network;
    this._abi = abi;
    this._privateKey = privateKey;
  }

  protected _loadContract(contractAddr: string) {
    const caver = new Caver(RPC_PROVIDER_MAP[this._network]);
    const deployer = caver.wallet.keyring.createFromPrivateKey(
      this._privateKey,
    );
    caver.wallet.add(deployer);

    return new caver.contract(this._abi as unknown as AbiItem[], contractAddr);
  }

  abstract deploy(
    contractAddr: string,
    mintedTokens: number[],
    metadataURI: string,
  ): void;
}
```

```jsx
src/deployer/klaytn/KlaytnNftDeployer.ts

import { TransactionReceipt } from 'caver-js';
import { Deployer } from './Deployer';

const deployer = '';
const gas = 150000000;

export class klaytnNftDeployer extends Deployer {
  public async deploy(
    contractAddr: string,
    mintedTokens: number[],
    metadataURI: string,
  ): Promise<void> {
    const contract = super._loadContract(contractAddr);

    for (const tokenId of mintedTokens) {
      const receipt: TransactionReceipt = await contract.methods
        .safeMint(deployer, metadataURI)
        .send({
          from: deployer,
          gas,
        });

      console.log(`tokenId: ${tokenId}, blockHash: ${receipt.blockHash}`);
    }
  }
}
```

**실행 script**

```jsx
import { IDeploy } from '../deployer/klaytn/IDeploy';
import { ABI } from 'caver-js';
import { Network } from './types';
import Erc721ABI from '../abi/erc721.json';
import { klaytnParser } from '../parser/klaytn/KlaytnParser';
import { klaytnNftDeployer } from '../deployer/klaytn/KlaytnNftDeployer';
import { IParser } from '../parser/klaytn/IParser';

const MAIN_CONTRACT = '';
const DEPLOY_CONTRACT = '';
const PRIVATE_KEY = '';

const tokenId = 'default';
const METADATA_URI = `https://metadata.io/box/${tokenId}.json`;

export const RPC_PROVIDER_MAP: { [key in Network]: string } = {
  //   [Network.Main]: 'https://public-node-api.klaytnapi.com/v1/cypress',
  [Network.Main]: 'https://klaytn-mainnet-rpc.allthatnode.com:8551',
	// 
  [Network.Test]: 'https://api.baobab.klaytn.net:8651/',
};

const ABI_MAP: { [key in Network]: any } = {
  [Network.Main]: Erc721ABI,
  [Network.Test]: ABI,
};

const KlaytnParserFactory = (network: Network, abi: ABI): IParser => {
  return new klaytnParser(network, abi);
};

const KlaytnNftDeployFactory = (
  network: Network,
  abi: ABI,
  privateKey: string,
): IDeploy => {
  return new klaytnNftDeployer(network, abi, privateKey);
};

(async () => {
  const parser = KlaytnParserFactory(Network.Main, ABI_MAP[Network.Main]);
  const mintedTokens = await parser.parse(MAIN_CONTRACT);
  const deployer = KlaytnNftDeployFactory(
    Network.Test,
    ABI_MAP[Network.Test],
    PRIVATE_KEY,
  );
  await deployer.deploy(DEPLOY_CONTRACT, mintedTokens, METADATA_URI);
})();
```

### 2. Smart Contract Interface 구현

- 실제 이 서비스에 어떤 기능이 필요한지 고민하는 과정

```jsx
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ILend {
    struct NftInfo {
        address addr;
        uint64 tokenId;
    }

    struct RentInfo {
        uint64 start;
        uint64 end;
        address user;
    }

    event RentInfoUpdate(
        uint256 rentId,
        uint64 start,
        uint64 end,
        address user
    );
    event ShareRatioUpdate(uint8 ratio);
    event MaxDurationUpdate(uint64 duration);

    event Stake(address msgSender, address nftAddress, uint256 tokenId);
    event Redeem(address msgSender, address nftAddress, uint256 tokenId);

    function rent(uint64 duration, address user) external;

    function couldRent() external view returns (bool);

    function stake(address nftAddress, uint256 tokenId) external;

    function redeem() external;

    function couldRedeem() external view returns (bool);

    function getUser() external view returns (address);

    function getNftInfo() external view returns (NftInfo memory info);

    function setShareRatio(uint8 shareRatio) external;

    function setMaxDuration(uint64 timeStamp) external;

    function getRentInfo() external view returns (RentInfo memory rent);

    function isValid() external view returns (bool);
}
```

### 3. Test 명세 작성

- 실제 기능의 세부 동작 과정 Spec 작성

```jsx
describe('Lend', () => {
  describe('stake', () => {
    it('Lend할 NFT를 스테이킹한다', () => {
      // given
      // when
      // then
    })
    it('NFT에 대한 권한을 가지고 있지 않다면 스테이킹할 수 없다.', () => {
      // given
      // when 
      // then
    })
    it('스테이킹되면 NftInfo(address, tokenId) 값을 업데이트한다.', () => {
      // given
      // when 
      // then
    })
    it('성공적으로 스테이킹 됐다면 Stake 이벤트가 발생한다.', () => {
      // given
      // when
      // then
    })
  })
  describe('redeem', () => {
    it('Renting 상태가 아닌 NFT를 회수한다.', () => {
      // given
      // when
      // then
    })
    it('Renting 상태라면 NFT를 회수할 수 없다.', () => {
      // given
      // when
      // then
    })
    it('Lender가 아니라면 회수할 수 없다.', () => {
      // given
      // when
      // then
    })
    it('성공적으로 회수되면 NftInfo(address, tokenId) 값을 초기화한다.', () => {
      // given
      // when 
      // then
    })
    it('성공적으로 회수되면 Redeem 이벤트가 발생한다.', () => {
      // given
      // when
      // then
    })
  })
  describe('rent', () => {
    it('Renting 상태가 아니라면 NFT를 빌릴 수 있다.', () => {
      // given
      // when
      // then
    })
    it('Renting 상태라면 NFT를 빌릴 수 없다.', () => {
      // given
      // when
      // then
    })
    it('빌리고자 하는 기간이 Lender가 설정한 MaxDuration보다 길다면 NFT를 빌릴 수 없다.', () => {
      // given
      // when
      // then
    })
    it('성공적으로 NFT를 빌렸다면 RentInfo를 업데이트한다.', () => {
      // given
      // when
      // then
    })
    it('성공적으로 NFT를 빌렸다면 RentInfoUpdate 이벤트가 발생한다.', () => {
      // given
      // when
      // then
    })
  })
  describe('couldRent', () => {
    it('NFT를 빌릴 수 있는 상태라면 true를 출력한다.', () => {
      // given
      // when
      // then
    })
    it('NFT를 빌릴 수 없는 상태라면 false를 출력한다.', () => {
      // given
      // when
      // then
    })
  })
  describe('couldRedeem', () => {
    it('NFT를 회수할 수 있는 상태라면 true를 출력한다.', () => {
      // given
      // when
      // then
    })
    it('NFT를 회수할 수 없는 상태라면 false를 출력한다.', ( ) => {
      // given
      // when
      // then
    })
  })
  describe('getUser', () => {
    it('NFT를 빌린 유저의 지갑 주소를 조회한다.', () => {
      // given
      // when
      // then
    })
    it('NFT를 빌린 유저가 없다면 address(0) 출력한다.', () => {
      // given
      // when
      // then
    })
  })
  describe('getNftInfo', () => {
    it('스테이킹된 NFT 정보(address, tokenId)를 조회한다.', () => {
      // given
      // when
      // then
    })
    it('스테이킹된 NFT 정보가 없다면 default 값을 출력한다.', () => {
      // given
      // when
      // then
    })
  })
  describe('setShareRatio', () => {
    it('Lender는 수익 공유 비율을 설정할 수 있다.', () => {
      // given
      // when
      // then
    })
    it('Lender가 아니라면 수익 공유 비율을 설정할 수 없다.', () => {
      // given
      // when
      // then
    })
    it('NFT가 Renting 상태라면 수익 공유 비율을 설정할 수 없다.', () => {
      // given
      // when
      // then
    })
    it('성공적으로 수익 공유 비율이 설정되었다면 ShareRatioUpdate 이벤트가 발생한다.', () => {
      // given
      // when
      // then
    })
  })
  describe('setMaxDuration', () => {
    it('Lender라면 최대 대여 기간 설정할 수 있다.', () => {
      // given
      // when
      // then
    })
    it('Lender가 아니라면 최대 대여 기간 설정할 수 없다.', () => {
      // given
      // when
      // then
    })
    it('NFT가 Renting 상태라면 최대 대여 기간을 설정할 수 없다.', () => {
      // given
      // when
      // then
    })
    it('성공적으로 최대 대여 기간이 설정되었다면 setMaxDuration 이벤트가 발생한다.', () => {
      // given
      // when
      // then
    })
  })
  describe('getRentInfo', () => {
    it('Renting 상태인 NFT의 RentInfo(start, end, user)를 조회한다.', () => {
      // given
      // when
      // then
    })
    it('Renting 상태가 아니라면 default 값을 출력한다.', () => {
      // given
      // when
      // then
    })
  })
  describe('isValid', () => {
    it('컨트랙트의 상태가 유효하다면 true를 출력한다.', () => {
      // given
      // when
      // then
    })
    it('컨트랙트의 상태가 유효하지 않다면 false를 출력한다.', () => {
      // given
      // when
      // then
    })
  })
})
```

### 4. Smart Contract 구현
